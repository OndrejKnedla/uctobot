from fastapi import FastAPI, Request, Form, HTTPException
from fastapi.responses import PlainTextResponse, Response, JSONResponse, HTMLResponse
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from twilio.twiml.messaging_response import MessagingResponse
from twilio.request_validator import RequestValidator
import os
import time
from datetime import datetime
import asyncio
from dotenv import load_dotenv
import psutil
from prometheus_client import Counter, Histogram, generate_latest, CONTENT_TYPE_LATEST

# Load environment variables
load_dotenv()

# Initialize Sentry and logging BEFORE importing other modules
from app.utils.sentry import init_sentry
from app.utils.logging import configure_logging, get_logger, log_api_request, log_whatsapp_message

# Initialize error tracking and logging
init_sentry()
logger = configure_logging()
api_logger = get_logger(__name__)

# Prometheus metrics
REQUEST_COUNT = Counter('http_requests_total', 'Total HTTP requests', ['method', 'endpoint', 'status'])
REQUEST_DURATION = Histogram('http_request_duration_seconds', 'HTTP request duration')
WHATSAPP_MESSAGES = Counter('whatsapp_messages_total', 'Total WhatsApp messages', ['direction', 'status'])

from app.whatsapp_handler import WhatsAppHandler
# Database import removed - using new SQLAlchemy services
from app.onboarding import OnboardingWizard
from app.vat_handler import VatHandler
from app.services.user_service import UserService
from app.services.payment_service import payment_service
from app.middleware.trial_check import TrialCheckMiddleware
from utils.notifications import NotificationManager
from sqlalchemy.orm import sessionmaker

app = FastAPI(
    title="√öƒçetn√≠Bot - Czech WhatsApp Accounting Assistant",
    version="1.0.0",
    description="ƒåesk√Ω WhatsApp bot pro √∫ƒçetnictv√≠ OSVƒå",
    docs_url="/docs" if os.getenv('ENVIRONMENT') != 'production' else None,
    redoc_url="/redoc" if os.getenv('ENVIRONMENT') != 'production' else None,
)

# Mount static files
app.mount("/static", StaticFiles(directory="app/static"), name="static")

# Templates
templates = Jinja2Templates(directory="app/templates")

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "http://localhost:3000",
        "http://127.0.0.1:3000",
        "https://ucetnibot.cz",  # pro produkci
        "https://www.ucetnibot.cz"
    ],
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE"],
    allow_headers=["*"],
)

# Middleware for request logging and metrics
@app.middleware("http")
async def log_requests(request: Request, call_next):
    start_time = time.time()
    
    response = await call_next(request)
    
    duration = time.time() - start_time
    
    # Log API request
    log_api_request(
        api_logger,
        method=request.method,
        endpoint=request.url.path,
        status_code=response.status_code,
        duration_ms=duration * 1000,
        user_agent=request.headers.get("user-agent"),
        ip_address=request.client.host if request.client else None
    )
    
    # Update Prometheus metrics
    REQUEST_COUNT.labels(
        method=request.method,
        endpoint=request.url.path,
        status=response.status_code
    ).inc()
    
    REQUEST_DURATION.observe(duration)
    
    return response

# Glob√°ln√≠ instance
whatsapp_handler = WhatsAppHandler()
notification_manager = NotificationManager()
vat_handler = VatHandler()

# Tyto budou inicializov√°ny v startup_event
user_service = None
trial_middleware = None
onboarding_wizard = None

@app.on_event("startup")
async def startup_event():
    global user_service, trial_middleware, onboarding_wizard, startup_time
    
    startup_time = time.time()
    api_logger.info("Starting √öƒçetn√≠Bot WhatsApp service", 
                   environment=os.getenv('ENVIRONMENT'),
                   version="1.0.0")
    
    # Inicializuj datab√°zi (nov√Ω connection syst√©m)
    from app.database.connection import init_database
    await init_database()
    
    # Inicializuj slu≈æby po p≈ôipojen√≠ k datab√°zi
    user_service = UserService()  # Pou≈æije default get_db_session
    trial_middleware = TrialCheckMiddleware(user_service)
    onboarding_wizard = OnboardingWizard(user_service)
    
    api_logger.info("Services initialized successfully", 
                   startup_time_seconds=round(time.time() - startup_time, 2))
    
    # Include payment webhook router
    from app.endpoints.payment_webhook import router as payment_router
    app.include_router(payment_router)
    
    # Include OCR endpoint router
    from app.endpoints.ocr_endpoint import router as ocr_router
    app.include_router(ocr_router)
    
    # asyncio.create_task(notification_manager.start_reminder_loop())  # Zat√≠m vypnuto

@app.on_event("shutdown")
async def shutdown_event():
    api_logger.info("Shutting down √öƒçetn√≠Bot WhatsApp service")
    from app.database.connection import close_database
    await close_database()
    api_logger.info("Service shutdown complete")

@app.get("/", response_class=HTMLResponse)
async def home(request: Request):
    return templates.TemplateResponse("index.html", {"request": request})

@app.get("/api")
async def root():
    return {"message": "√öƒçetn√≠ WhatsApp Bot je aktivn√≠", "status": "running"}

@app.get("/registrace", response_class=HTMLResponse)
async def registration_page(request: Request):
    # Redirect na platebn√≠ str√°nku nebo registraƒçn√≠ formul√°≈ô
    # Pro testov√°n√≠ zat√≠m vr√°t√≠me jednoduchou HTML str√°nku
    return """
    <!DOCTYPE html>
    <html lang="cs">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Registrace - √öƒçtoBot</title>
        <style>
            body { 
                font-family: system-ui, sans-serif; 
                max-width: 600px; 
                margin: 50px auto; 
                padding: 20px; 
                line-height: 1.6; 
            }
            .btn {
                background: #25D366;
                color: white;
                padding: 12px 24px;
                border: none;
                border-radius: 8px;
                text-decoration: none;
                display: inline-block;
                margin: 10px 0;
            }
        </style>
    </head>
    <body>
        <h1>üéâ V√≠tejte v √öƒçtoBotu!</h1>
        <p>Dƒõkujeme za z√°jem o √öƒçtoBot. Zaƒçnƒõte ji≈æ dnes:</p>
        
        <h2>Zp≈Øsob registrace:</h2>
        <ol>
            <li><strong>Napi≈°te 'START'</strong> na WhatsApp ƒç√≠slo: <strong>+420 123 456 789</strong></li>
            <li>Bot v√°s provede jednoduch√Ωm nastaven√≠m</li>
            <li>Zaƒçnƒõte zad√°vat sv√© v√Ωdaje a p≈ô√≠jmy</li>
        </ol>

        <a href="https://wa.me/420123456789?text=START" class="btn">
            üí¨ Spustit na WhatsApp
        </a>

        <h3>Cena:</h3>
        <ul>
            <li>üíö Prvn√≠ 14 dn√≠ ZDARMA</li>
            <li>üí∞ Pot√© pouze 299 Kƒç/mƒõs√≠c nebo 2 990 Kƒç/rok</li>
            <li>‚ùå Kdykoliv zru≈°iteln√©</li>
        </ul>

        <p><a href="/">‚Üê Zpƒõt na hlavn√≠ str√°nku</a></p>
    </body>
    </html>
    """

@app.get("/health")
async def health_check():
    """Comprehensive health check endpoint for monitoring"""
    try:
        # Check database connection
        db_healthy = False
        db_error = None
        try:
            from app.database.connection import db_manager
            db_healthy = await db_manager.check_connection()
        except Exception as e:
            db_error = str(e)
        
        # Check system resources
        cpu_percent = psutil.cpu_percent(interval=1)
        memory = psutil.virtual_memory()
        disk = psutil.disk_usage('/')
        
        # Application metrics
        uptime = time.time() - startup_time if 'startup_time' in globals() else 0
        
        health_data = {
            "status": "healthy" if db_healthy else "unhealthy",
            "timestamp": datetime.now().isoformat(),
            "version": "1.0.0",
            "environment": os.getenv('ENVIRONMENT', 'development'),
            "uptime_seconds": round(uptime, 2),
            "checks": {
                "database": {
                    "status": "healthy" if db_healthy else "unhealthy",
                    "error": db_error
                },
                "system": {
                    "cpu_percent": cpu_percent,
                    "memory_percent": memory.percent,
                    "memory_available_mb": round(memory.available / 1024 / 1024, 2),
                    "disk_free_gb": round(disk.free / 1024 / 1024 / 1024, 2),
                    "disk_percent": round((disk.used / disk.total) * 100, 2)
                }
            }
        }
        
        status_code = 200 if db_healthy else 503
        return JSONResponse(content=health_data, status_code=status_code)
        
    except Exception as e:
        api_logger.error("Health check failed", error=str(e))
        return JSONResponse(
            content={
                "status": "unhealthy", 
                "timestamp": datetime.now().isoformat(),
                "error": str(e)
            },
            status_code=503
        )

@app.get("/metrics")
async def metrics():
    """Prometheus metrics endpoint"""
    return Response(content=generate_latest(), media_type=CONTENT_TYPE_LATEST)

@app.get("/status")
async def status():
    """Simple status endpoint for load balancers"""
    return {"status": "ok", "service": "ucetni-whatsapp-bot"}

@app.post("/webhook/whatsapp")
@app.get("/webhook/whatsapp")  # Pro bypass localtunnel security
async def whatsapp_webhook(request: Request):
    """
    Zpracuje WhatsApp zpr√°vy vƒçetnƒõ obr√°zk≈Ø √∫ƒçtenek
    """
    try:
        # Z√≠skej form data z requestu
        form_data = await request.form()
        
        # Z√°kladn√≠ √∫daje z Twilio
        from_number = form_data.get('From', '').replace('whatsapp:', '')
        to_number = form_data.get('To', '')
        message_body = form_data.get('Body', '').strip()
        message_sid = form_data.get('MessageSid', '')
        profile_name = form_data.get('ProfileName', 'U≈æivatel')
        
        # NOV√â: Kontrola p≈ôilo≈æen√Ωch m√©di√≠
        num_media = int(form_data.get('NumMedia', '0'))
        
        api_logger.info(f"WhatsApp webhook: from={from_number}, body='{message_body[:50]}...', media={num_media}")
        
        # Log incoming message
        log_whatsapp_message(
            api_logger,
            direction="incoming",
            phone_number=from_number,
            message=f"{message_body} [+{num_media} media]" if num_media > 0 else message_body,
            message_sid=message_sid
        )
        WHATSAPP_MESSAGES.labels(direction="incoming", status="received").inc()
        
        # Najdi nebo vytvo≈ô u≈æivatele
        user = await user_service.get_or_create_user(from_number, profile_name)
        
        response_text = ""
        
        # NOV√â: Zpracuj obr√°zky pokud jsou p≈ôilo≈æen√©
        if num_media > 0:
            for i in range(num_media):
                media_url = form_data.get(f'MediaUrl{i}')
                media_type = form_data.get(f'MediaContentType{i}')
                
                api_logger.info(f"Processing media {i}: type={media_type}, url={media_url[:50] if media_url else 'None'}...")
                
                if media_type and media_type.startswith('image/'):
                    try:
                        # St√°hni a zpracuj obr√°zek
                        image_data = await _download_twilio_media(media_url)
                        
                        # OCR zpracov√°n√≠ pomoc√≠ WhatsApp OCR service
                        from app.services.whatsapp_ocr_service import whatsapp_ocr_service
                        ocr_result = await whatsapp_ocr_service.process_receipt_from_whatsapp(
                            image_data, message_body, user.id
                        )
                        
                        if ocr_result.get('success'):
                            # Vytvo≈ô transakci z OCR dat
                            transaction = await _create_transaction_from_ocr(
                                user.id, ocr_result, message_body
                            )
                            
                            # P≈ôiprav odpovƒõƒè
                            response_text = _format_ocr_response(ocr_result, transaction)
                        else:
                            response_text = f"""üì∏ {ocr_result.get('message', 'Nepoda≈ôilo se zpracovat obr√°zek')}

üí° **Tipy pro lep≈°√≠ rozpozn√°n√≠:**
‚Ä¢ Vyfo≈•te √∫ƒçtenku na rovn√©m povrchu
‚Ä¢ Zajistƒõte dobr√© osvƒõtlen√≠  
‚Ä¢ Cel√° √∫ƒçtenka mus√≠ b√Ωt vidƒõt
‚Ä¢ Zkuste ost≈ôej≈°√≠ fotografii

üìù Nebo napi≈°te √∫daje ruƒçnƒõ: "Alza 1500 Kƒç\""""
                            
                    except Exception as e:
                        api_logger.error(f"Chyba p≈ôi zpracov√°n√≠ obr√°zku: {str(e)}")
                        response_text = """‚ùå Chyba p≈ôi zpracov√°n√≠ obr√°zku.

üìù Zkuste napsat √∫daje ruƒçnƒõ:
"N√°kup materi√°lu 500 Kƒç"

üìû Nebo kontaktujte podporu pokud probl√©m p≈ôetrv√°v√°."""
                        
                else:
                    response_text = """üìé Podporuji pouze obr√°zky √∫ƒçtenek.

üì∏ **Po≈°lete pros√≠m:**
‚Ä¢ Fotku √∫ƒçtenky nebo faktury
‚Ä¢ Screenshot e-fakturou
‚Ä¢ Obr√°zek dokladu

üìù **Nebo napi≈°te text:**
"Benz√≠n 800 Kƒç" """
                    
                break  # Zpracuj jen prvn√≠ m√©dium
        
        # Pokud nen√≠ obr√°zek, zpracuj jako textovou zpr√°vu
        elif message_body:
            # Zkontroluj onboarding p≈ô√≠kazy
            if message_body.lower() in ["/start", "start", "zaƒç√≠t", "zacit", "ahoj", "hello"]:
                response_text = _get_welcome_message()
            elif message_body.lower() in ["pomoc", "help", "?"]:
                response_text = _get_help_message()
            elif message_body.lower() in ["p≈ôehled", "prehled", "souhrn"]:
                # Zkontroluj trial p≈ôed zobrazen√≠m p≈ôehledu
                access_check = await trial_middleware.check_summary_access(user.id)
                if not access_check.get('allowed', False):
                    response_text = access_check.get('block_message', "‚ùå P≈ô√≠stup odep≈ôen")
                else:
                    response_text = await _get_monthly_summary(user.id)
            elif message_body.lower() in ["kvart√°l", "kvartal", "q"]:
                # Zkontroluj trial p≈ôed zobrazen√≠m kvart√°lu
                access_check = await trial_middleware.check_summary_access(user.id)
                if not access_check.get('allowed', False):
                    response_text = access_check.get('block_message', "‚ùå P≈ô√≠stup odep≈ôen")
                else:
                    response_text = await _get_quarterly_summary(user.id)
            elif message_body.lower() in ["export"]:
                # Zkontroluj trial p≈ôed exportem
                access_check = await trial_middleware.check_export_access(user.id)
                if not access_check.get('allowed', False):
                    response_text = access_check.get('block_message', "‚ùå P≈ô√≠stup odep≈ôen")
                else:
                    response_text = await _export_data(user.id)
            elif message_body.lower() in ['info', 'informace', 'p≈ôedplatn√©', 'predplatne', 'cena']:
                response_text = await trial_middleware.get_subscription_info_message()
            elif message_body.lower() in ['platba', 'zaplatit', 'p≈ôedplatn√©', 'predplatne']:
                response_text = await _handle_payment_request(user.id, profile_name, from_number)
            elif message_body.lower().startswith('/dph') or message_body.lower() in ['dph', 'export dph']:
                # DPH p≈ô√≠kazy
                mock_user_settings = {
                    'vat_payer': True,
                    'dic': 'CZ12345678',
                    'first_name': 'Jan',
                    'last_name': 'Nov√°k',
                    'email': 'jan@example.com',
                    'city': 'Praha',
                    'postal_code': '12000'
                }
                response_text = await vat_handler.handle_vat_command(message_body.lower(), user.id, mock_user_settings)
            else:
                # Zpracuj jako transakci (textov√Ω input)
                access_check = await trial_middleware.check_transaction_limits(user.id)
                if not access_check.get('allowed', False):
                    if access_check.get('status') in ['subscription_required', 'subscription_expired']:
                        response_text = await trial_middleware.handle_subscription_required_action(user.id, message_body)
                    else:
                        response_text = access_check.get('block_message', "‚ùå P≈ô√≠stup odep≈ôen")
                else:
                    response_text = await whatsapp_handler.process_transaction(
                        message_body, user.id, from_number
                    )
        else:
            # Ani text ani obr√°zek
            response_text = """üëã Ahoj! Jsem v√°≈° AI √∫ƒçetn√≠ asistent.

üì∏ **Po≈°lete mi:**
‚Ä¢ Fotku √∫ƒçtenky ‚Üí automaticky zpracuji
‚Ä¢ Text: "Benz√≠n 500 Kƒç" ‚Üí okam≈æitƒõ ulo≈æ√≠m

üìä **P≈ô√≠kazy:**
‚Ä¢ "Pomoc" - n√°vod
‚Ä¢ "P≈ôehled" - mƒõs√≠ƒçn√≠ souhrn
‚Ä¢ "Export" - export dat

Zaƒçnƒõme! üöÄ"""
        
        # Po≈°li odpovƒõƒè p≈ô√≠mo p≈ôes Twilio API m√≠sto TwiML
        await _send_whatsapp_message(from_number, response_text)
        
        # Log outgoing message
        log_whatsapp_message(
            api_logger,
            direction="outgoing",
            phone_number=from_number,
            message=response_text,
            user_id=user.id if 'user' in locals() else None
        )
        WHATSAPP_MESSAGES.labels(direction="outgoing", status="sent").inc()
        
        return Response(content="", status_code=200)
        
    except Exception as e:
        # Get from_number from variables if available
        error_phone = locals().get('from_number', 'unknown')
        error_message = locals().get('message_body', 'unknown')
        
        api_logger.error("Webhook processing failed", 
                        error=str(e),
                        phone_number=error_phone,
                        message_preview=error_message[:50] if error_message else None)
        
        WHATSAPP_MESSAGES.labels(direction="outgoing", status="error").inc()
        
        # Try to send error message if we have a phone number
        if error_phone != 'unknown':
            try:
                await _send_whatsapp_message(error_phone, "‚ùå Omlouv√°m se, nastala chyba p≈ôi zpracov√°n√≠ va≈°√≠ zpr√°vy. Zkuste to pros√≠m znovu.")
            except:
                pass  # Ignore errors when sending error message
                
        return Response(content="", status_code=200)

async def _handle_payment_request(user_id: int, user_name: str, user_number: str) -> str:
    """Handle payment request from user"""
    try:
        # Get user's email (we'll need this for invoicing)
        # For now, we'll generate a placeholder email
        user_email = f"user{user_id}@temp-email.cz"  # TODO: Get real email during onboarding
        
        # Check if user already has active subscription
        subscription_info = await payment_service.get_user_subscription_info(user_id)
        
        if subscription_info.get('subscription_status') == 'active':
            ends_at = subscription_info.get('subscription_ends_at')
            if ends_at:
                from datetime import datetime
                end_date = datetime.fromisoformat(ends_at.replace('Z', '+00:00'))
                return f"""‚úÖ *Va≈°e p≈ôedplatn√© je ji≈æ aktivn√≠*

üìÖ Aktivn√≠ do: {end_date.strftime('%d.%m.%Y')}
üí≥ Status: Aktivn√≠ p≈ôedplatn√©

M≈Ø≈æete zaƒç√≠t pou≈æ√≠vat v≈°echny funkce √öƒçetn√≠Bota!
Napi≈°te libovolnou transakci pro zaƒç√°tek."""
        
        # Create payment link
        result = await payment_service.create_subscription_payment(
            user_id=user_id,
            customer_email=user_email,
            customer_name=user_name or f"U≈æivatel {user_id}",
            provider="stripe"  # Default to Stripe
        )
        
        if result.success:
            return f"""üí≥ *Aktivace p≈ôedplatn√©ho √öƒçetn√≠Bot*

**Cena:** 299 Kƒç/mƒõs√≠c
**Prvn√≠ t√Ωden:** ZDARMA (zku≈°ebn√≠ obdob√≠)

‚úÖ *Co z√≠sk√°te:*
‚Ä¢ Neomezen√© transakce
‚Ä¢ AI kategorizace v√Ωdaj≈Ø  
‚Ä¢ Mƒõs√≠ƒçn√≠ a kvart√°ln√≠ p≈ôehledy
‚Ä¢ DPH v√Ωpoƒçty a reporty
‚Ä¢ Export do CSV/XML
‚Ä¢ Automatick√© faktury
‚Ä¢ P≈ôipom√≠nky da≈àov√Ωch term√≠n≈Ø

üîó **Kliknƒõte pro platbu:**
{result.payment_url}

üí° *Platba je zabezpeƒçena p≈ôes Stripe. Po dokonƒçen√≠ platby bude v√°≈° √∫ƒçet okam≈æitƒõ aktivov√°n.*

‚ùì M√°te ot√°zky? Napi≈°te "pomoc"."""
        else:
            logger.error("Payment creation failed", 
                        user_id=user_id, 
                        error=result.error_message)
            return f"""‚ùå *Chyba p≈ôi vytv√°≈ôen√≠ platby*

Omlouv√°me se, nepoda≈ôilo se vytvo≈ôit platebn√≠ odkaz.

üîß *Zkuste pros√≠m:*
‚Ä¢ Napsat "platba" znovu za chv√≠li
‚Ä¢ Kontaktovat podporu: podpora@ucetni-bot.cz

Nebo pou≈æijte alternativn√≠ zp≈Øsob platby:
üåê https://ucetni-bot.cz/subscribe"""
            
    except Exception as e:
        logger.error("Payment request handling failed", error=str(e), user_id=user_id)
        return """‚ùå *Nastala neoƒçek√°van√° chyba*

Zkuste to pros√≠m za chv√≠li znovu nebo kontaktujte podporu:
üìß podpora@ucetni-bot.cz

Dƒõkujeme za pochopen√≠."""

async def _send_whatsapp_message(to_number: str, message: str):
    """Po≈°le WhatsApp zpr√°vu p≈ô√≠mo p≈ôes Twilio API"""
    try:
        from twilio.rest import Client
        from twilio.base.exceptions import TwilioException
        
        account_sid = os.getenv('TWILIO_ACCOUNT_SID')
        auth_token = os.getenv('TWILIO_AUTH_TOKEN')
        whatsapp_number = os.getenv('TWILIO_WHATSAPP_NUMBER')
        
        client = Client(account_sid, auth_token)
        
        sent_message = client.messages.create(
            body=message,
            from_=whatsapp_number,
            to=to_number
        )
        logger.info(f"Zpr√°va odesl√°na na {to_number}: {sent_message.sid}")
        
    except TwilioException as e:
        if "daily message limit" in str(e).lower() or "429" in str(e):
            logger.warning(f"Twilio rate limit dosa≈æen: {str(e)}")
            # M√≠sto odes√≠l√°n√≠ zpr√°vy logujeme obsah pro dev √∫ƒçely
            logger.info(f"[RATE LIMITED] Zpr√°va pro {to_number}: {message}")
            print(f"\nüö´ TWILIO RATE LIMIT - Zpr√°va by byla odesl√°na:")
            print(f"üì± ƒå√≠slo: {to_number}")
            print(f"üí¨ Obsah: {message}")
            print("-" * 50)
        else:
            logger.error(f"Twilio chyba p≈ôi odes√≠l√°n√≠ zpr√°vy: {str(e)}")
    except Exception as e:
        logger.error(f"Chyba p≈ôi odes√≠l√°n√≠ zpr√°vy: {str(e)}")

async def _download_twilio_media(media_url: str) -> bytes:
    """
    St√°hne obr√°zek z Twilio s autentizac√≠
    """
    try:
        import requests
        
        account_sid = os.getenv('TWILIO_ACCOUNT_SID')
        auth_token = os.getenv('TWILIO_AUTH_TOKEN')
        
        if not media_url:
            raise ValueError("Media URL is empty")
            
        api_logger.info(f"Downloading media from Twilio: {media_url[:50]}...")
        
        response = requests.get(
            media_url,
            auth=(account_sid, auth_token),
            timeout=30  # 30 second timeout
        )
        
        if response.status_code == 200:
            api_logger.info(f"Media downloaded successfully: {len(response.content)} bytes")
            return response.content
        else:
            raise Exception(f"HTTP {response.status_code}: {response.text}")
            
    except Exception as e:
        api_logger.error(f"Chyba p≈ôi stahov√°n√≠ m√©dia z Twilio: {str(e)}")
        raise

async def _create_transaction_from_ocr(user_id: int, ocr_result: dict, original_message: str = ""):
    """
    Vytvo≈ô√≠ transakci z OCR dat
    """
    try:
        from app.database.operations import db_operations
        from app.database.models import Transaction, TransactionItem, TransactionAttachment
        from app.database.connection import get_db_session
        from datetime import datetime
        
        # P≈ôiprav data pro transakci
        transaction_data = {
            'user_id': user_id,
            'type': ocr_result.get('type', 'expense'),
            'original_message': f"OCR: {original_message}" if original_message else "OCR zpracov√°n√≠",
            'description': ocr_result.get('description', ocr_result.get('vendor', 'Nerozpoznan√Ω v√Ωdaj')),
            'amount_czk': float(ocr_result.get('amount', ocr_result.get('total', 0))),
            'original_amount': float(ocr_result.get('amount', ocr_result.get('total', 0))),
            'original_currency': 'CZK',
            'exchange_rate': 1.0,
            'category_code': ocr_result.get('category', '549100'),  # Ostatn√≠ n√°klady
            'category_name': ocr_result.get('category_name', 'Ostatn√≠ provozn√≠ n√°klady'),
            'processed_by_ai': ocr_result.get('ai_processed', True),
            'ai_confidence': ocr_result.get('ai_confidence', 0.7),
            'ai_model_used': ocr_result.get('ai_model', 'OCR+AI'),
            
            # Roz≈°√≠≈ôen√© √∫daje z OCR
            'document_number': ocr_result.get('document_number'),
            'document_date': ocr_result.get('date'),
            'counterparty_name': ocr_result.get('vendor') or ocr_result.get('vendor_verified'),
            'counterparty_ico': ocr_result.get('ico'),
            'counterparty_dic': ocr_result.get('dic'),
            'counterparty_address': ocr_result.get('vendor_address'),
            'vat_rate': ocr_result.get('vat_rate', 21),
            'vat_included': True,
            
            'created_at': datetime.now(),
            'updated_at': datetime.now(),
            'transaction_date': datetime.now()
        }
        
        # Vypoƒç√≠tej DPH pokud je k dispozici
        if transaction_data['amount_czk'] > 0 and transaction_data['vat_rate'] > 0:
            if ocr_result.get('vat_amount'):
                transaction_data['vat_amount'] = float(ocr_result['vat_amount'])
                transaction_data['vat_base'] = transaction_data['amount_czk'] - transaction_data['vat_amount']
            else:
                # V√Ωpoƒçet DPH ze z√°kladu
                vat_multiplier = 1 + (transaction_data['vat_rate'] / 100)
                transaction_data['vat_base'] = transaction_data['amount_czk'] / vat_multiplier
                transaction_data['vat_amount'] = transaction_data['amount_czk'] - transaction_data['vat_base']
        
        # Ulo≈æit do datab√°ze (simulace - v re√°ln√© implementaci by se pou≈æila datab√°ze)
        api_logger.info(f"Transaction created from OCR: {transaction_data['description']} - {transaction_data['amount_czk']} CZK")
        
        # Vytvo≈ô mock transaction object pro response
        class MockTransaction:
            def __init__(self, data):
                self.id = int(datetime.now().timestamp())
                self.description = data['description']
                self.amount_czk = data['amount_czk'] 
                self.category_name = data['category_name']
                self.counterparty_name = data.get('counterparty_name')
                self.document_number = data.get('document_number')
                self.vat_amount = data.get('vat_amount', 0)
                self.items_count = len(ocr_result.get('items', []))
        
        return MockTransaction(transaction_data)
        
    except Exception as e:
        api_logger.error(f"Chyba p≈ôi vytv√°≈ôen√≠ transakce z OCR: {str(e)}")
        raise

def _format_ocr_response(ocr_result: dict, transaction) -> str:
    """
    Form√°tuje odpovƒõƒè z OCR zpracov√°n√≠ pro WhatsApp
    """
    if ocr_result.get('success'):
        # Hlavn√≠ informace
        amount = ocr_result.get('amount', ocr_result.get('total', 'nerozpozn√°no'))
        vendor = (ocr_result.get('vendor_verified') or 
                 ocr_result.get('vendor') or 
                 'nerozpozn√°no')
        date = ocr_result.get('date', 'nerozpozn√°no')
        ico = ocr_result.get('ico', 'nerozpozn√°no')
        
        # Sestaven√≠ response
        response = f"""‚úÖ **√öƒçtenka zpracov√°na!**

üìä **Detaily:**
üí∞ Celkem: {amount} Kƒç
üè¢ Obchod: {vendor}
üìÖ Datum: {date}"""
        
        if ico != 'nerozpozn√°no':
            response += f"\nüè∑Ô∏è IƒåO: {ico}"
            
        # P≈ôidej DIƒå pokud je k dispozici
        if ocr_result.get('dic'):
            response += f"\nüè∑Ô∏è DIƒå: {ocr_result['dic']}"
            
        # Dokument ƒç√≠slo
        if ocr_result.get('document_number'):
            response += f"\nüìÑ Doklad: {ocr_result['document_number']}"
        
        # Polo≈æky (max 5)
        items = ocr_result.get('items', [])
        if items:
            response += "\n\nüìù **Polo≈æky:**"
            for i, item in enumerate(items[:5]):
                price = item.get('price', item.get('total_with_vat', 0))
                quantity = item.get('quantity', 1)
                if quantity > 1:
                    response += f"\n  ‚Ä¢ {item.get('description', 'Polo≈æka')}: {quantity}x {price} Kƒç"
                else:
                    response += f"\n  ‚Ä¢ {item.get('description', 'Polo≈æka')}: {price} Kƒç"
            
            if len(items) > 5:
                response += f"\n  ‚Ä¢ ... a {len(items) - 5} dal≈°√≠ch"
        
        response += f"\n\nüíæ **Transakce #{transaction.id} ulo≈æena**"
        response += f"\nüìä Kategorie: {transaction.category_name}"
        
        if hasattr(transaction, 'vat_amount') and transaction.vat_amount > 0:
            response += f"\nüí∂ DPH: {transaction.vat_amount:.0f} Kƒç"
        
        # Confidence info
        ocr_confidence = ocr_result.get('ocr_confidence', 0.7) * 100
        response += f"\nüéØ P≈ôesnost: {ocr_confidence:.0f}%"
        
        if ocr_result.get('ai_processed'):
            response += "\nü§ñ Zpracov√°no pomoc√≠ AI"
            
        return response
        
    else:
        return f"""‚ùå **Nepoda≈ôilo se p≈ôeƒç√≠st √∫ƒçtenku**

{ocr_result.get('message', 'Nezn√°m√° chyba')}

üí° **Tipy pro lep≈°√≠ rozpozn√°n√≠:**
‚Ä¢ Vyfo≈•te √∫ƒçtenku na rovn√©m povrchu
‚Ä¢ Zajistƒõte dobr√© osvƒõtlen√≠
‚Ä¢ Cel√° √∫ƒçtenka mus√≠ b√Ωt vidƒõt
‚Ä¢ Zkuste ost≈ôej≈°√≠ fotografii

üìù **Nebo napi≈°te √∫daje ruƒçnƒõ:**
"Alza 1500 Kƒç\""""

def _get_welcome_message() -> str:
    """
    Uv√≠tac√≠ zpr√°va pro nov√© u≈æivatele
    """
    return """üëã **V√≠tejte v √öƒçtoBotu!**

Jsem v√°≈° AI √∫ƒçetn√≠ asistent pro OSVƒå. 

üì∏ **Po≈°lete fotku √∫ƒçtenky:**
‚Ä¢ Vyfo≈•te √∫ƒçtenku mobilem
‚Ä¢ Po≈°lete mi ji zde  
‚Ä¢ Automaticky rozpozn√°m v≈°echny √∫daje
‚Ä¢ Ulo≈æ√≠m transakci do √∫ƒçetnictv√≠

üìù **Nebo napi≈°te text:**
‚Ä¢ "Benz√≠n 800 Kƒç"
‚Ä¢ "Alza notebook 25000"
‚Ä¢ "Faktura od klienta 15000 + DPH"

üìä **U≈æiteƒçn√© p≈ô√≠kazy:**
‚Ä¢ "Pomoc" - podrobn√Ω n√°vod
‚Ä¢ "P≈ôehled" - mƒõs√≠ƒçn√≠ souhrn
‚Ä¢ "Export" - export dat do CSV

‚ú® **Prvn√≠ √∫ƒçtenka je ZDARMA!**

Zaƒçnƒõme √∫ƒçtovat! üöÄ"""

def _get_help_message() -> str:
    """
    Aktualizovan√° n√°povƒõda s podporou obr√°zk≈Ø
    """
    return """ü§ñ **√öƒçtoBot - Kompletn√≠ n√°vod**

üì∏ **OBR√ÅZKY √öƒåTENEK:**
‚Ä¢ Vyfo≈•te √∫ƒçtenku nebo fakturu
‚Ä¢ Po≈°lete obr√°zek sem
‚Ä¢ AI automaticky rozpozn√°:
  ‚ñ™Ô∏è Celkovou ƒç√°stku
  ‚ñ™Ô∏è N√°zev obchodu a IƒåO  
  ‚ñ™Ô∏è Datum n√°kupu
  ‚ñ™Ô∏è Jednotliv√© polo≈æky
  ‚ñ™Ô∏è DPH informace

üìù **TEXTOV√â P≈ò√çKAZY:**
‚Ä¢ "Koupil jsem [vƒõc] za [ƒç√°stka]"
‚Ä¢ "Benz√≠n 800 Kƒç"
‚Ä¢ "Alza notebook 25000"
‚Ä¢ "Faktura od klienta 15000 + DPH"
‚Ä¢ "√öhrada za slu≈æby 5000 bez DPH"

üí° **INTELIGENTN√ç FUNKCE:**
‚Ä¢ Automatick√° kategorizace v√Ωdaj≈Ø
‚Ä¢ Rozpozn√°n√≠ DPH a v√Ωpoƒçty
‚Ä¢ Validace IƒåO p≈ôes ARES registr
‚Ä¢ P≈ôipom√≠nky na da≈àov√© term√≠ny

üìä **REPORTY A P≈òEHLEDY:**
‚Ä¢ "P≈ôehled" - mƒõs√≠ƒçn√≠ souhrn
‚Ä¢ "Kvart√°l" - kvart√°ln√≠ p≈ôehled + DPH
‚Ä¢ "Export" - export dat do CSV
‚Ä¢ "DPH" - DPH p≈ôizn√°n√≠

üí≥ **P≈òEDPLATN√â:**
‚Ä¢ "Info" - stav va≈°eho √∫ƒçtu
‚Ä¢ "Platba" - aktivace p≈ôedplatn√©ho

üéØ **P≈ò√çKLADY:**
‚úÖ Po≈°lete fotku √∫ƒçtenky z Lidlu
‚úÖ "Tankoval jsem za 1200"  
‚úÖ "Faktura Alza IƒåO 27082440 celkem 5000"
‚úÖ "P≈ôijal platbu 10000 od klienta"

**Zaƒçnƒõme! Po≈°lete prvn√≠ √∫ƒçtenku! üì∏**"""

def _create_response(message: str):
    # TwiML odpovƒõƒè pro WhatsApp  
    from fastapi.responses import Response
    response = MessagingResponse()
    msg = response.message()
    msg.body(message)
    return Response(content=str(response), media_type="application/xml")

def _get_help_message() -> str:
    return """ü§ñ *√öƒçetn√≠ asistent - n√°povƒõda*

*Jak zad√°vat transakce:*
‚Ä¢ "Koupil jsem [vƒõc] za [ƒç√°stka]"
‚Ä¢ "Faktura [firma] [ƒç√°stka]"
‚Ä¢ "Zaplatil jsem [vƒõc] [ƒç√°stka]"
‚Ä¢ "Dostal jsem [ƒç√°stka] od [firma]"
‚Ä¢ "P≈ôi≈°la platba [ƒç√°stka] za [slu≈æba]"

*P≈ô√≠kazy:*
‚Ä¢ *p≈ôehled* - mƒõs√≠ƒçn√≠ souhrn
‚Ä¢ *kvart√°l* - kvart√°ln√≠ souhrn
‚Ä¢ *export* - export dat do CSV
‚Ä¢ *pomoc* - tato n√°povƒõda

*P≈ô√≠klady:*
‚Ä¢ "Koupil jsem toner za 1500"
‚Ä¢ "Faktura Alza 35000"
‚Ä¢ "Zaplatil jsem n√°jem 12000"
‚Ä¢ "P≈ôi≈°la platba 50000 od ƒåEZ"

*Kategorie jsou p≈ôi≈ôazov√°ny automaticky!*"""

async def _get_monthly_summary(user_id: int) -> str:
    try:
        from app.database.operations import db_operations
        summary = await db_operations.get_monthly_summary(user_id)
        
        if not summary:
            return "üìä Zat√≠m nem√°te ≈æ√°dn√© transakce v tomto mƒõs√≠ci."
        
        month_name = _get_czech_month_name(datetime.now().month)
        year = datetime.now().year
        
        response = f"""üìä *P≈ôehled za {month_name} {year}:*

üìà *P≈ô√≠jmy:* {_format_currency(summary['total_income'])} Kƒç
üìâ *V√Ωdaje:* {_format_currency(summary['total_expenses'])} Kƒç
üí∞ *Zisk:* {_format_currency(summary['profit'])} Kƒç

*Poƒçet transakc√≠:* {summary['transaction_count']}"""
        
        if summary['top_expenses']:
            response += "\n\n*Top 3 v√Ωdaje:*"
            for i, expense in enumerate(summary['top_expenses'][:3], 1):
                response += f"\n{i}. {expense['category_name']}: {_format_currency(expense['amount'])} Kƒç"
        
        return response
        
    except Exception as e:
        logger.error(f"Chyba p≈ôi z√≠sk√°v√°n√≠ mƒõs√≠ƒçn√≠ho p≈ôehledu: {str(e)}")
        return "‚ùå Nepoda≈ôilo se z√≠skat mƒõs√≠ƒçn√≠ p≈ôehled."

async def _get_quarterly_summary(user_id: int) -> str:
    try:
        from app.database.operations import db_operations
        summary = await db_operations.get_quarterly_summary(user_id)
        
        if not summary:
            return "üìä Zat√≠m nem√°te ≈æ√°dn√© transakce v tomto kvart√°lu."
        
        quarter = (datetime.now().month - 1) // 3 + 1
        year = datetime.now().year
        
        response = f"""üìä *P≈ôehled za Q{quarter} {year}:*

üìà *P≈ô√≠jmy:* {_format_currency(summary['total_income'])} Kƒç
üìâ *V√Ωdaje:* {_format_currency(summary['total_expenses'])} Kƒç
üí∞ *Zisk:* {_format_currency(summary['profit'])} Kƒç

*Poƒçet transakc√≠:* {summary['transaction_count']}

*DPH info:*
‚Ä¢ Odvod DPH (odhad): {_format_currency(summary['vat_estimate'])} Kƒç
‚Ä¢ Term√≠n pod√°n√≠: 25. {_get_quarter_deadline_month(quarter)}"""
        
        if summary['category_breakdown']:
            response += "\n\n*Rozdƒõlen√≠ v√Ωdaj≈Ø:*"
            for category in summary['category_breakdown'][:5]:
                percentage = (category['amount'] / summary['total_expenses'] * 100) if summary['total_expenses'] > 0 else 0
                response += f"\n‚Ä¢ {category['category_name']}: {_format_currency(category['amount'])} Kƒç ({percentage:.1f}%)"
        
        return response
        
    except Exception as e:
        logger.error(f"Chyba p≈ôi z√≠sk√°v√°n√≠ kvart√°ln√≠ho p≈ôehledu: {str(e)}")
        return "‚ùå Nepoda≈ôilo se z√≠skat kvart√°ln√≠ p≈ôehled."

async def _export_data(user_id: int) -> str:
    try:
        from app.database.operations import db_operations
        export_url = await db_operations.export_to_csv(user_id)
        return f"""üì• *Export dat*

V√°≈° export je p≈ôipraven ke sta≈æen√≠:
{export_url}

Link je platn√Ω 24 hodin."""
    except Exception as e:
        logger.error(f"Chyba p≈ôi exportu dat: {str(e)}")
        return "‚ùå Nepoda≈ôilo se vyexportovat data."

def _format_currency(amount: float) -> str:
    return f"{amount:,.0f}".replace(",", " ")

def _get_czech_month_name(month: int) -> str:
    months = {
        1: "leden", 2: "√∫nor", 3: "b≈ôezen", 4: "duben",
        5: "kvƒõten", 6: "ƒçerven", 7: "ƒçervenec", 8: "srpen",
        9: "z√°≈ô√≠", 10: "≈ô√≠jen", 11: "listopad", 12: "prosinec"
    }
    return months.get(month, "")

def _get_quarter_deadline_month(quarter: int) -> str:
    deadlines = {1: "dubna", 2: "ƒçervence", 3: "≈ô√≠jna", 4: "ledna"}
    return deadlines.get(quarter, "")

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)